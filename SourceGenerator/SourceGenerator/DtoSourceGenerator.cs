using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerator;

[Generator]
public class DtoSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "DtoGenerators";
    private const string AttributeName = "DtoAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeName}<TEntity> : System.Attribute
    {{
        
    }}
}}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.isAttributeFound)
            .Select((t, _) => t.classDeclarationSyntax);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }
    
    /// <summary>
    /// Checks whether the Node is annotated with the attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax classDeclarationSyntax, bool isAttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();
            
            // Check the full name of the attribute.
            if (attributeName.StartsWith($"{Namespace}.{AttributeName}<") && attributeName.EndsWith(">"))
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;

            var genericParameter = classSymbol.GetAttributes()
                .Select(attribute =>
                {
                    var attributeClass = attribute.AttributeClass;

                    if (attributeClass is null || !attributeClass.IsGenericType || !attributeClass.Arity.Equals(1))
                        return null;

                    return attributeClass.TypeArguments.First();
                }).FirstOrDefault(x => x != null);
            
            var methodBody = genericParameter?.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(p =>
                {
                    if (p.GetAttributes().Any(x => x.AttributeClass?.Name == "JsonIgnoreAttribute"))
                        return null;

                    if (p.Type.Name != "String" && p.Type.Interfaces
                            .Any(x => x.SpecialType is
                                SpecialType.System_Collections_IEnumerable or
                                SpecialType.System_Collections_Generic_IEnumerable_T or
                                SpecialType.System_Array or
                                SpecialType.System_Collections_Generic_IList_T or
                                SpecialType.System_Collections_Generic_ICollection_T or
                                SpecialType.System_Collections_Generic_IReadOnlyList_T))
                    {
                        ITypeSymbol finalType;
                        var type = (p.Type as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();

                        var symbols = compilation.GetSymbolsWithName($"{type?.Name}");

                        if (symbols.Count() > 1)
                        {
                            // finalType = symbols.FirstOrDefault(x => x.ContainingNamespace.Name == "").Type;
                        }
                        
                        return "// " + compilation.GetSymbolsWithName($"{type?.Name}").Count();
                        // return "// " + (type?.Name ?? "---");
                    }
                    
                    return $"    public {p.Type} {p.Name} {{ get; set; }}";
                })
                ?? [];
            
            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {namespaceName};

partial class {className}
{{
{string.Join("\n", methodBody)}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}